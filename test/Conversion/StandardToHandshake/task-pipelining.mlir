// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// RUN: circt-opt -lower-std-to-handshake %s --split-input-file | FileCheck %s

// CHECK-LABEL:   handshake.func @simpleDiamond(
// CHECK-SAME:                                  %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                  %[[VAL_1:.*]]: i64,
// CHECK-SAME:                                  %[[VAL_2:.*]]: none, ...) -> none
// CHECK:           %[[VAL_3:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_4:.*]]:3 = fork [3] %[[VAL_3]] : i1
// CHECK:           %[[VAL_5:.*]] = buffer [2] fifo %[[VAL_4]]#0 : i1
// CHECK:           %[[VAL_6:.*]]:2 = fork [2] %[[VAL_5]] : i1
// CHECK:           %[[VAL_7:.*]] = merge %[[VAL_1]] : i64
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_4]]#2, %[[VAL_7]] : i64
// CHECK:           %[[VAL_10:.*]], %[[VAL_11:.*]] = cond_br %[[VAL_4]]#1, %[[VAL_2]] : none
// CHECK:           %[[VAL_12:.*]], %[[VAL_13:.*]] = control_merge %[[VAL_10]] : none
// CHECK:           sink %[[VAL_13]] : index
// CHECK:           %[[VAL_14:.*]] = merge %[[VAL_8]] : i64
// CHECK:           %[[VAL_15:.*]] = br %[[VAL_12]] : none
// CHECK:           %[[VAL_16:.*]] = br %[[VAL_14]] : i64
// CHECK:           %[[VAL_17:.*]], %[[VAL_18:.*]] = control_merge %[[VAL_11]] : none
// CHECK:           sink %[[VAL_18]] : index
// CHECK:           %[[VAL_19:.*]] = merge %[[VAL_9]] : i64
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_17]] : none
// CHECK:           %[[VAL_21:.*]] = br %[[VAL_19]] : i64
// CHECK:           %[[VAL_22:.*]] = mux %[[VAL_6]]#1 {{\[}}%[[VAL_20]], %[[VAL_15]]] : i1, none
// CHECK:           %[[VAL_23:.*]] = arith.index_cast %[[VAL_6]]#0 : i1 to index
// CHECK:           %[[VAL_24:.*]] = mux %[[VAL_23]] {{\[}}%[[VAL_21]], %[[VAL_16]]] : index, i64
// CHECK:           sink %[[VAL_24]] : i64
// CHECK:           return %[[VAL_22]] : none
// CHECK:         }
func.func @simpleDiamond(%arg0: i1, %arg1: i64) {
  cf.cond_br %arg0, ^bb1(%arg1: i64), ^bb2(%arg1: i64)
^bb1(%v1: i64):  // pred: ^bb0
  cf.br ^bb3(%v1: i64)
^bb2(%v2: i64):  // pred: ^bb0
  cf.br ^bb3(%v2: i64)
^bb3(%v3: i64):  // 2 preds: ^bb1, ^bb2
  return
}

// -----

// CHECK-LABEL:   handshake.func @nestedDiamond(
// CHECK-SAME:                                  %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                  %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:4 = fork [4] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]] = buffer [2] fifo %[[VAL_3]]#0 : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_4]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_3]]#2, %[[VAL_3]]#3 : i1
// CHECK:           sink %[[VAL_7]] : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_1]] : none
// CHECK:           %[[VAL_10:.*]] = merge %[[VAL_6]] : i1
// CHECK:           %[[VAL_11:.*]]:2 = fork [2] %[[VAL_10]] : i1
// CHECK:           %[[VAL_12:.*]] = buffer [2] fifo %[[VAL_11]]#0 : i1
// CHECK:           %[[VAL_13:.*]]:2 = fork [2] %[[VAL_12]] : i1
// CHECK:           %[[VAL_14:.*]], %[[VAL_15:.*]] = control_merge %[[VAL_8]] : none
// CHECK:           sink %[[VAL_15]] : index
// CHECK:           %[[VAL_16:.*]], %[[VAL_17:.*]] = cond_br %[[VAL_11]]#1, %[[VAL_14]] : none
// CHECK:           %[[VAL_18:.*]], %[[VAL_19:.*]] = control_merge %[[VAL_16]] : none
// CHECK:           sink %[[VAL_19]] : index
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_18]] : none
// CHECK:           %[[VAL_21:.*]], %[[VAL_22:.*]] = control_merge %[[VAL_17]] : none
// CHECK:           sink %[[VAL_22]] : index
// CHECK:           %[[VAL_23:.*]] = br %[[VAL_21]] : none
// CHECK:           %[[VAL_24:.*]], %[[VAL_25:.*]] = control_merge %[[VAL_9]] : none
// CHECK:           sink %[[VAL_25]] : index
// CHECK:           %[[VAL_26:.*]] = br %[[VAL_24]] : none
// CHECK:           %[[VAL_27:.*]] = mux %[[VAL_13]]#1 {{\[}}%[[VAL_23]], %[[VAL_20]]] : i1, none
// CHECK:           %[[VAL_28:.*]] = arith.index_cast %[[VAL_13]]#0 : i1 to index
// CHECK:           sink %[[VAL_28]] : index
// CHECK:           %[[VAL_29:.*]] = br %[[VAL_27]] : none
// CHECK:           %[[VAL_30:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_26]], %[[VAL_29]]] : i1, none
// CHECK:           %[[VAL_31:.*]]:2 = fork [2] %[[VAL_30]] : none
// CHECK:           %[[VAL_32:.*]] = constant %[[VAL_31]]#0 {value = true} : i1
// CHECK:           %[[VAL_33:.*]] = arith.xori %[[VAL_5]]#0, %[[VAL_32]] : i1
// CHECK:           %[[VAL_34:.*]] = arith.index_cast %[[VAL_33]] : i1 to index
// CHECK:           sink %[[VAL_34]] : index
// CHECK:           return %[[VAL_31]]#1 : none
// CHECK:         }
func.func @nestedDiamond(%arg0: i1) {
  cf.cond_br %arg0, ^bb1, ^bb4
^bb1:  // pred: ^bb0
  cf.cond_br %arg0, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  cf.br ^bb5
^bb3:  // pred: ^bb1
  cf.br ^bb5
^bb4:  // pred: ^bb0
  cf.br ^bb6
^bb5:  // 2 preds: ^bb2, ^bb3
  cf.br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  return
}

// -----

// CHECK-LABEL:   handshake.func @triangle(
// CHECK-SAME:                             %[[VAL_0:.*]]: i1,
// CHECK-SAME:                             %[[VAL_1:.*]]: i64,
// CHECK-SAME:                             %[[VAL_2:.*]]: none, ...) -> none
// CHECK:           %[[VAL_3:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_4:.*]]:3 = fork [3] %[[VAL_3]] : i1
// CHECK:           %[[VAL_5:.*]] = buffer [2] fifo %[[VAL_4]]#0 : i1
// CHECK:           %[[VAL_6:.*]]:2 = fork [2] %[[VAL_5]] : i1
// CHECK:           %[[VAL_7:.*]] = merge %[[VAL_1]] : i64
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_4]]#2, %[[VAL_7]] : i64
// CHECK:           %[[VAL_10:.*]], %[[VAL_11:.*]] = cond_br %[[VAL_4]]#1, %[[VAL_2]] : none
// CHECK:           %[[VAL_12:.*]], %[[VAL_13:.*]] = control_merge %[[VAL_10]] : none
// CHECK:           sink %[[VAL_13]] : index
// CHECK:           %[[VAL_14:.*]] = merge %[[VAL_8]] : i64
// CHECK:           %[[VAL_15:.*]] = br %[[VAL_12]] : none
// CHECK:           %[[VAL_16:.*]] = br %[[VAL_14]] : i64
// CHECK:           %[[VAL_17:.*]] = mux %[[VAL_6]]#1 {{\[}}%[[VAL_11]], %[[VAL_15]]] : i1, none
// CHECK:           %[[VAL_18:.*]]:2 = fork [2] %[[VAL_17]] : none
// CHECK:           %[[VAL_19:.*]] = constant %[[VAL_18]]#0 {value = true} : i1
// CHECK:           %[[VAL_20:.*]] = arith.xori %[[VAL_6]]#0, %[[VAL_19]] : i1
// CHECK:           %[[VAL_21:.*]] = arith.index_cast %[[VAL_20]] : i1 to index
// CHECK:           %[[VAL_22:.*]] = mux %[[VAL_21]] {{\[}}%[[VAL_16]], %[[VAL_9]]] : index, i64
// CHECK:           sink %[[VAL_22]] : i64
// CHECK:           return %[[VAL_18]]#1 : none
// CHECK:         }
func.func @triangle(%arg0: i1, %val0: i64) {
  cf.cond_br %arg0, ^bb1(%val0: i64), ^bb2(%val0: i64)
^bb1(%val1: i64):  // pred: ^bb0
  cf.br ^bb2(%val1: i64)
^bb2(%val2: i64):  // 2 preds: ^bb0, ^bb1
  return
}

// -----

// CHECK-LABEL:   handshake.func @nestedTriangle(
// CHECK-SAME:                                   %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                   %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:4 = fork [4] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]] = buffer [2] fifo %[[VAL_3]]#0 : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_4]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_3]]#2, %[[VAL_3]]#3 : i1
// CHECK:           sink %[[VAL_7]] : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_1]] : none
// CHECK:           %[[VAL_10:.*]] = merge %[[VAL_6]] : i1
// CHECK:           %[[VAL_11:.*]]:2 = fork [2] %[[VAL_10]] : i1
// CHECK:           %[[VAL_12:.*]] = buffer [2] fifo %[[VAL_11]]#0 : i1
// CHECK:           %[[VAL_13:.*]]:2 = fork [2] %[[VAL_12]] : i1
// CHECK:           %[[VAL_14:.*]], %[[VAL_15:.*]] = control_merge %[[VAL_8]] : none
// CHECK:           sink %[[VAL_15]] : index
// CHECK:           %[[VAL_16:.*]], %[[VAL_17:.*]] = cond_br %[[VAL_11]]#1, %[[VAL_14]] : none
// CHECK:           %[[VAL_18:.*]], %[[VAL_19:.*]] = control_merge %[[VAL_16]] : none
// CHECK:           sink %[[VAL_19]] : index
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_18]] : none
// CHECK:           %[[VAL_21:.*]] = mux %[[VAL_13]]#1 {{\[}}%[[VAL_17]], %[[VAL_20]]] : i1, none
// CHECK:           %[[VAL_22:.*]]:2 = fork [2] %[[VAL_21]] : none
// CHECK:           %[[VAL_23:.*]] = constant %[[VAL_22]]#0 {value = true} : i1
// CHECK:           %[[VAL_24:.*]] = arith.xori %[[VAL_13]]#0, %[[VAL_23]] : i1
// CHECK:           %[[VAL_25:.*]] = arith.index_cast %[[VAL_24]] : i1 to index
// CHECK:           sink %[[VAL_25]] : index
// CHECK:           %[[VAL_26:.*]] = br %[[VAL_22]]#1 : none
// CHECK:           %[[VAL_27:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_9]], %[[VAL_26]]] : i1, none
// CHECK:           %[[VAL_28:.*]]:2 = fork [2] %[[VAL_27]] : none
// CHECK:           %[[VAL_29:.*]] = constant %[[VAL_28]]#0 {value = true} : i1
// CHECK:           %[[VAL_30:.*]] = arith.xori %[[VAL_5]]#0, %[[VAL_29]] : i1
// CHECK:           %[[VAL_31:.*]] = arith.index_cast %[[VAL_30]] : i1 to index
// CHECK:           sink %[[VAL_31]] : index
// CHECK:           return %[[VAL_28]]#1 : none
// CHECK:         }
func.func @nestedTriangle(%arg0: i1) {
  cf.cond_br %arg0, ^bb1, ^bb4
^bb1:  // pred: ^bb0
  cf.cond_br %arg0, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  cf.br ^bb3
^bb3:  // 2 preds: ^bb1, ^bb2
  cf.br ^bb4
^bb4:  // 2 preds: ^bb0, ^bb3
  return
}

// -----

// CHECK-LABEL:   handshake.func @multiple_blocks_needed(
// CHECK-SAME:                                           %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                           %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:4 = fork [4] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]] = buffer [2] fifo %[[VAL_3]]#0 : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_4]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_3]]#2, %[[VAL_3]]#3 : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_1]] : none
// CHECK:           %[[VAL_10:.*]] = merge %[[VAL_6]] : i1
// CHECK:           %[[VAL_11:.*]]:4 = fork [4] %[[VAL_10]] : i1
// CHECK:           %[[VAL_12:.*]] = buffer [2] fifo %[[VAL_11]]#0 : i1
// CHECK:           %[[VAL_13:.*]]:2 = fork [2] %[[VAL_12]] : i1
// CHECK:           %[[VAL_14:.*]], %[[VAL_15:.*]] = control_merge %[[VAL_8]] : none
// CHECK:           sink %[[VAL_15]] : index
// CHECK:           %[[VAL_16:.*]], %[[VAL_17:.*]] = cond_br %[[VAL_11]]#2, %[[VAL_11]]#3 : i1
// CHECK:           %[[VAL_18:.*]], %[[VAL_19:.*]] = cond_br %[[VAL_11]]#1, %[[VAL_14]] : none
// CHECK:           %[[VAL_20:.*]] = merge %[[VAL_16]] : i1
// CHECK:           %[[VAL_21:.*]], %[[VAL_22:.*]] = control_merge %[[VAL_18]] : none
// CHECK:           sink %[[VAL_22]] : index
// CHECK:           %[[VAL_23:.*]] = br %[[VAL_20]] : i1
// CHECK:           %[[VAL_24:.*]] = br %[[VAL_21]] : none
// CHECK:           %[[VAL_25:.*]] = mux %[[VAL_26:.*]] {{\[}}%[[VAL_23]], %[[VAL_17]]] : index, i1
// CHECK:           %[[VAL_27:.*]] = mux %[[VAL_13]]#1 {{\[}}%[[VAL_19]], %[[VAL_24]]] : i1, none
// CHECK:           %[[VAL_28:.*]]:2 = fork [2] %[[VAL_27]] : none
// CHECK:           %[[VAL_29:.*]] = constant %[[VAL_28]]#0 {value = true} : i1
// CHECK:           %[[VAL_30:.*]] = arith.xori %[[VAL_13]]#0, %[[VAL_29]] : i1
// CHECK:           %[[VAL_26]] = arith.index_cast %[[VAL_30]] : i1 to index
// CHECK:           %[[VAL_31:.*]] = br %[[VAL_25]] : i1
// CHECK:           %[[VAL_32:.*]] = br %[[VAL_28]]#1 : none
// CHECK:           %[[VAL_33:.*]] = mux %[[VAL_34:.*]] {{\[}}%[[VAL_31]], %[[VAL_7]]] : index, i1
// CHECK:           %[[VAL_35:.*]]:4 = fork [4] %[[VAL_33]] : i1
// CHECK:           %[[VAL_36:.*]] = buffer [2] fifo %[[VAL_35]]#0 : i1
// CHECK:           %[[VAL_37:.*]]:2 = fork [2] %[[VAL_36]] : i1
// CHECK:           %[[VAL_38:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_9]], %[[VAL_32]]] : i1, none
// CHECK:           %[[VAL_39:.*]]:2 = fork [2] %[[VAL_38]] : none
// CHECK:           %[[VAL_40:.*]] = constant %[[VAL_39]]#0 {value = true} : i1
// CHECK:           %[[VAL_41:.*]] = arith.xori %[[VAL_5]]#0, %[[VAL_40]] : i1
// CHECK:           %[[VAL_34]] = arith.index_cast %[[VAL_41]] : i1 to index
// CHECK:           %[[VAL_42:.*]], %[[VAL_43:.*]] = cond_br %[[VAL_35]]#2, %[[VAL_35]]#3 : i1
// CHECK:           sink %[[VAL_43]] : i1
// CHECK:           %[[VAL_44:.*]], %[[VAL_45:.*]] = cond_br %[[VAL_35]]#1, %[[VAL_39]]#1 : none
// CHECK:           %[[VAL_46:.*]] = merge %[[VAL_42]] : i1
// CHECK:           %[[VAL_47:.*]]:2 = fork [2] %[[VAL_46]] : i1
// CHECK:           %[[VAL_48:.*]] = buffer [2] fifo %[[VAL_47]]#0 : i1
// CHECK:           %[[VAL_49:.*]]:2 = fork [2] %[[VAL_48]] : i1
// CHECK:           %[[VAL_50:.*]], %[[VAL_51:.*]] = control_merge %[[VAL_44]] : none
// CHECK:           sink %[[VAL_51]] : index
// CHECK:           %[[VAL_52:.*]], %[[VAL_53:.*]] = cond_br %[[VAL_47]]#1, %[[VAL_50]] : none
// CHECK:           %[[VAL_54:.*]], %[[VAL_55:.*]] = control_merge %[[VAL_52]] : none
// CHECK:           sink %[[VAL_55]] : index
// CHECK:           %[[VAL_56:.*]] = br %[[VAL_54]] : none
// CHECK:           %[[VAL_57:.*]] = mux %[[VAL_49]]#1 {{\[}}%[[VAL_53]], %[[VAL_56]]] : i1, none
// CHECK:           %[[VAL_58:.*]]:2 = fork [2] %[[VAL_57]] : none
// CHECK:           %[[VAL_59:.*]] = constant %[[VAL_58]]#0 {value = true} : i1
// CHECK:           %[[VAL_60:.*]] = arith.xori %[[VAL_49]]#0, %[[VAL_59]] : i1
// CHECK:           %[[VAL_61:.*]] = arith.index_cast %[[VAL_60]] : i1 to index
// CHECK:           sink %[[VAL_61]] : index
// CHECK:           %[[VAL_62:.*]] = br %[[VAL_58]]#1 : none
// CHECK:           %[[VAL_63:.*]] = mux %[[VAL_37]]#1 {{\[}}%[[VAL_45]], %[[VAL_62]]] : i1, none
// CHECK:           %[[VAL_64:.*]]:2 = fork [2] %[[VAL_63]] : none
// CHECK:           %[[VAL_65:.*]] = constant %[[VAL_64]]#0 {value = true} : i1
// CHECK:           %[[VAL_66:.*]] = arith.xori %[[VAL_37]]#0, %[[VAL_65]] : i1
// CHECK:           %[[VAL_67:.*]] = arith.index_cast %[[VAL_66]] : i1 to index
// CHECK:           sink %[[VAL_67]] : index
// CHECK:           return %[[VAL_64]]#1 : none
// CHECK:         }
func.func @multiple_blocks_needed(%arg0: i1) {
  cf.cond_br %arg0, ^bb1, ^bb4
^bb1:  // pred: ^bb0
  cf.cond_br %arg0, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  cf.br ^bb3
^bb3:  // 2 preds: ^bb1, ^bb2
  cf.br ^bb4
^bb4:  // 2 preds: ^bb0, ^bb3
  cf.cond_br %arg0, ^bb5, ^bb8
^bb5:  // pred: ^bb4
  cf.cond_br %arg0, ^bb6, ^bb7
^bb6:  // pred: ^bb5
  cf.br ^bb7
^bb7:  // 2 preds: ^bb5, ^bb6
  cf.br ^bb8
^bb8:  // 2 preds: ^bb4, ^bb7
  return
}

// -----

// CHECK-LABEL:   handshake.func @sameSuccessor(
// CHECK-SAME:                                  %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                  %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:2 = fork [2] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]]:2 = fork [2] %[[VAL_1]] : none
// CHECK:           %[[VAL_5:.*]], %[[VAL_6:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_4]]#1 : none
// CHECK:           %[[VAL_7:.*]]:2 = fork [2] %[[VAL_5]] : none
// CHECK:           sink %[[VAL_6]] : none
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#0, %[[VAL_4]]#0 : none
// CHECK:           sink %[[VAL_9]] : none
// CHECK:           sink %[[VAL_8]] : none
// CHECK:           %[[VAL_10:.*]], %[[VAL_11:.*]] = control_merge %[[VAL_7]]#0, %[[VAL_7]]#1 : none
// CHECK:           sink %[[VAL_11]] : index
// CHECK:           return %[[VAL_10]] : none
// CHECK:         }
func.func @sameSuccessor(%cond: i1) {
  cf.cond_br %cond, ^1, ^1
^1:
  return
}

// -----

// CHECK-LABEL:   handshake.func @simple_loop(
// CHECK-SAME:                                %[[VAL_0:.*]]: i64,
// CHECK-SAME:                                %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i64
// CHECK:           %[[VAL_3:.*]]:2 = fork [2] %[[VAL_1]] : none
// CHECK:           %[[VAL_4:.*]] = constant %[[VAL_3]]#0 {value = 1 : i64} : i64
// CHECK:           %[[VAL_5:.*]] = br %[[VAL_2]] : i64
// CHECK:           %[[VAL_6:.*]] = br %[[VAL_3]]#1 : none
// CHECK:           %[[VAL_7:.*]] = br %[[VAL_4]] : i64
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = control_merge %[[VAL_6]] : none
// CHECK:           %[[VAL_10:.*]]:2 = fork [2] %[[VAL_9]] : index
// CHECK:           %[[VAL_11:.*]] = buffer [1] seq %[[VAL_12:.*]] {initValues = [0]} : i1
// CHECK:           %[[VAL_13:.*]]:3 = fork [3] %[[VAL_11]] : i1
// CHECK:           %[[VAL_14:.*]] = mux %[[VAL_13]]#2 {{\[}}%[[VAL_8]], %[[VAL_15:.*]]] : i1, none
// CHECK:           %[[VAL_16:.*]]:2 = fork [2] %[[VAL_14]] : none
// CHECK:           %[[VAL_17:.*]] = mux %[[VAL_10]]#1 {{\[}}%[[VAL_5]]] : index, i64
// CHECK:           %[[VAL_18:.*]] = mux %[[VAL_13]]#1 {{\[}}%[[VAL_17]], %[[VAL_19:.*]]] : i1, i64
// CHECK:           %[[VAL_20:.*]]:2 = fork [2] %[[VAL_18]] : i64
// CHECK:           %[[VAL_21:.*]] = mux %[[VAL_10]]#0 {{\[}}%[[VAL_7]]] : index, i64
// CHECK:           %[[VAL_22:.*]] = mux %[[VAL_13]]#0 {{\[}}%[[VAL_21]], %[[VAL_23:.*]]] : i1, i64
// CHECK:           %[[VAL_24:.*]]:2 = fork [2] %[[VAL_22]] : i64
// CHECK:           %[[VAL_25:.*]] = arith.cmpi eq, %[[VAL_24]]#0, %[[VAL_20]]#0 : i64
// CHECK:           %[[VAL_26:.*]]:4 = fork [4] %[[VAL_25]] : i1
// CHECK:           %[[VAL_27:.*]], %[[VAL_28:.*]] = cond_br %[[VAL_26]]#3, %[[VAL_20]]#1 : i64
// CHECK:           sink %[[VAL_27]] : i64
// CHECK:           %[[VAL_29:.*]] = constant %[[VAL_16]]#0 {value = true} : i1
// CHECK:           %[[VAL_30:.*]] = arith.xori %[[VAL_26]]#0, %[[VAL_29]] : i1
// CHECK:           %[[VAL_12]] = merge %[[VAL_30]] : i1
// CHECK:           %[[VAL_31:.*]], %[[VAL_32:.*]] = cond_br %[[VAL_26]]#2, %[[VAL_16]]#1 : none
// CHECK:           %[[VAL_33:.*]], %[[VAL_34:.*]] = cond_br %[[VAL_26]]#1, %[[VAL_24]]#1 : i64
// CHECK:           sink %[[VAL_33]] : i64
// CHECK:           %[[VAL_35:.*]] = merge %[[VAL_34]] : i64
// CHECK:           %[[VAL_36:.*]] = merge %[[VAL_28]] : i64
// CHECK:           %[[VAL_37:.*]], %[[VAL_38:.*]] = control_merge %[[VAL_32]] : none
// CHECK:           %[[VAL_39:.*]]:2 = fork [2] %[[VAL_37]] : none
// CHECK:           sink %[[VAL_38]] : index
// CHECK:           %[[VAL_40:.*]] = constant %[[VAL_39]]#0 {value = 1 : i64} : i64
// CHECK:           %[[VAL_41:.*]] = arith.addi %[[VAL_35]], %[[VAL_40]] : i64
// CHECK:           %[[VAL_19]] = br %[[VAL_36]] : i64
// CHECK:           %[[VAL_15]] = br %[[VAL_39]]#1 : none
// CHECK:           %[[VAL_23]] = br %[[VAL_41]] : i64
// CHECK:           %[[VAL_42:.*]], %[[VAL_43:.*]] = control_merge %[[VAL_31]] : none
// CHECK:           sink %[[VAL_43]] : index
// CHECK:           return %[[VAL_42]] : none
// CHECK:         }
func.func @simple_loop(%arg0: i64) {
  %c1_i64 = arith.constant 1 : i64
  cf.br ^bb1(%c1_i64 : i64)
^bb1(%0: i64):  // 2 preds: ^bb0, ^bb2
  %1 = arith.cmpi eq, %0, %arg0 : i64
  cf.cond_br %1, ^bb3, ^bb2
^bb2:  // pred: ^bb1
  %c1_i64_0 = arith.constant 1 : i64
  %2 = arith.addi %0, %c1_i64_0 : i64
  cf.br ^bb1(%2 : i64)
^bb3:  // pred: ^bb1
  return
}

// -----

// CHECK-LABEL:   handshake.func @blockWith3PredsAndLoop(
// CHECK-SAME:                                           %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                           %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:4 = fork [4] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]] = buffer [2] fifo %[[VAL_3]]#0 : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_4]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_3]]#2, %[[VAL_3]]#3 : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_1]] : none
// CHECK:           %[[VAL_10:.*]] = merge %[[VAL_6]] : i1
// CHECK:           %[[VAL_11:.*]]:2 = fork [2] %[[VAL_10]] : i1
// CHECK:           %[[VAL_12:.*]] = buffer [2] fifo %[[VAL_11]]#0 : i1
// CHECK:           %[[VAL_13:.*]]:2 = fork [2] %[[VAL_12]] : i1
// CHECK:           %[[VAL_14:.*]], %[[VAL_15:.*]] = control_merge %[[VAL_8]] : none
// CHECK:           sink %[[VAL_15]] : index
// CHECK:           %[[VAL_16:.*]], %[[VAL_17:.*]] = cond_br %[[VAL_11]]#1, %[[VAL_14]] : none
// CHECK:           %[[VAL_18:.*]], %[[VAL_19:.*]] = control_merge %[[VAL_16]] : none
// CHECK:           sink %[[VAL_19]] : index
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_18]] : none
// CHECK:           %[[VAL_21:.*]], %[[VAL_22:.*]] = control_merge %[[VAL_17]] : none
// CHECK:           sink %[[VAL_22]] : index
// CHECK:           %[[VAL_23:.*]] = br %[[VAL_21]] : none
// CHECK:           %[[VAL_24:.*]] = merge %[[VAL_7]] : i1
// CHECK:           %[[VAL_25:.*]], %[[VAL_26:.*]] = control_merge %[[VAL_9]] : none
// CHECK:           sink %[[VAL_26]] : index
// CHECK:           %[[VAL_27:.*]] = br %[[VAL_24]] : i1
// CHECK:           %[[VAL_28:.*]] = br %[[VAL_25]] : none
// CHECK:           %[[VAL_29:.*]], %[[VAL_30:.*]] = control_merge %[[VAL_28]] : none
// CHECK:           %[[VAL_31:.*]] = buffer [1] seq %[[VAL_32:.*]] {initValues = [0]} : i1
// CHECK:           %[[VAL_33:.*]]:2 = fork [2] %[[VAL_31]] : i1
// CHECK:           %[[VAL_34:.*]] = mux %[[VAL_33]]#1 {{\[}}%[[VAL_29]], %[[VAL_35:.*]]] : i1, none
// CHECK:           %[[VAL_36:.*]]:2 = fork [2] %[[VAL_34]] : none
// CHECK:           %[[VAL_37:.*]] = mux %[[VAL_30]] {{\[}}%[[VAL_27]]] : index, i1
// CHECK:           %[[VAL_38:.*]] = mux %[[VAL_33]]#0 {{\[}}%[[VAL_37]], %[[VAL_39:.*]]] : i1, i1
// CHECK:           %[[VAL_40:.*]]:4 = fork [4] %[[VAL_38]] : i1
// CHECK:           %[[VAL_41:.*]], %[[VAL_42:.*]] = cond_br %[[VAL_40]]#0, %[[VAL_40]]#1 : i1
// CHECK:           sink %[[VAL_41]] : i1
// CHECK:           %[[VAL_43:.*]] = constant %[[VAL_36]]#0 {value = true} : i1
// CHECK:           %[[VAL_44:.*]] = arith.xori %[[VAL_40]]#3, %[[VAL_43]] : i1
// CHECK:           %[[VAL_32]] = merge %[[VAL_44]] : i1
// CHECK:           %[[VAL_45:.*]], %[[VAL_46:.*]] = cond_br %[[VAL_40]]#2, %[[VAL_36]]#1 : none
// CHECK:           %[[VAL_47:.*]] = merge %[[VAL_42]] : i1
// CHECK:           %[[VAL_48:.*]], %[[VAL_49:.*]] = control_merge %[[VAL_46]] : none
// CHECK:           sink %[[VAL_49]] : index
// CHECK:           %[[VAL_39]] = br %[[VAL_47]] : i1
// CHECK:           %[[VAL_35]] = br %[[VAL_48]] : none
// CHECK:           %[[VAL_50:.*]] = mux %[[VAL_13]]#1 {{\[}}%[[VAL_23]], %[[VAL_20]]] : i1, none
// CHECK:           %[[VAL_51:.*]] = arith.index_cast %[[VAL_13]]#0 : i1 to index
// CHECK:           sink %[[VAL_51]] : index
// CHECK:           %[[VAL_52:.*]] = br %[[VAL_50]] : none
// CHECK:           %[[VAL_53:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_45]], %[[VAL_52]]] : i1, none
// CHECK:           %[[VAL_54:.*]]:2 = fork [2] %[[VAL_53]] : none
// CHECK:           %[[VAL_55:.*]] = constant %[[VAL_54]]#0 {value = true} : i1
// CHECK:           %[[VAL_56:.*]] = arith.xori %[[VAL_5]]#0, %[[VAL_55]] : i1
// CHECK:           %[[VAL_57:.*]] = arith.index_cast %[[VAL_56]] : i1 to index
// CHECK:           sink %[[VAL_57]] : index
// CHECK:           return %[[VAL_54]]#1 : none
// CHECK:         }
func.func @blockWith3PredsAndLoop(%arg0: i1) {
  cf.cond_br %arg0, ^bb1, ^bb4
^bb1:  // pred: ^bb0
  cf.cond_br %arg0, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  cf.br ^bb7
^bb3:  // pred: ^bb1
  cf.br ^bb7
^bb4:  // pred: ^bb0
  cf.br ^bb5
^bb5:  // 2 preds: ^bb4, ^bb6
  cf.cond_br %arg0, ^bb8, ^bb6
^bb6:  // pred: ^bb5
  cf.br ^bb5
^bb7:  // 2 preds: ^bb2, ^bb3
  cf.br ^bb8
^bb8:  // 2 preds: ^bb5, ^bb7
  return
}

// -----

// CHECK-LABEL:   handshake.func @otherBlockOrder(
// CHECK-SAME:                                    %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                    %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:4 = fork [4] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]] = buffer [2] fifo %[[VAL_3]]#0 : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_4]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_3]]#2, %[[VAL_3]]#3 : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_1]] : none
// CHECK:           %[[VAL_10:.*]] = merge %[[VAL_6]] : i1
// CHECK:           %[[VAL_11:.*]]:2 = fork [2] %[[VAL_10]] : i1
// CHECK:           %[[VAL_12:.*]] = buffer [2] fifo %[[VAL_11]]#0 : i1
// CHECK:           %[[VAL_13:.*]]:2 = fork [2] %[[VAL_12]] : i1
// CHECK:           %[[VAL_14:.*]], %[[VAL_15:.*]] = control_merge %[[VAL_8]] : none
// CHECK:           sink %[[VAL_15]] : index
// CHECK:           %[[VAL_16:.*]], %[[VAL_17:.*]] = cond_br %[[VAL_11]]#1, %[[VAL_14]] : none
// CHECK:           %[[VAL_18:.*]], %[[VAL_19:.*]] = control_merge %[[VAL_16]] : none
// CHECK:           sink %[[VAL_19]] : index
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_18]] : none
// CHECK:           %[[VAL_21:.*]], %[[VAL_22:.*]] = control_merge %[[VAL_17]] : none
// CHECK:           sink %[[VAL_22]] : index
// CHECK:           %[[VAL_23:.*]] = br %[[VAL_21]] : none
// CHECK:           %[[VAL_24:.*]] = merge %[[VAL_7]] : i1
// CHECK:           %[[VAL_25:.*]], %[[VAL_26:.*]] = control_merge %[[VAL_9]] : none
// CHECK:           sink %[[VAL_26]] : index
// CHECK:           %[[VAL_27:.*]] = br %[[VAL_24]] : i1
// CHECK:           %[[VAL_28:.*]] = br %[[VAL_25]] : none
// CHECK:           %[[VAL_29:.*]], %[[VAL_30:.*]] = control_merge %[[VAL_28]] : none
// CHECK:           %[[VAL_31:.*]] = buffer [1] seq %[[VAL_32:.*]] {initValues = [0]} : i1
// CHECK:           %[[VAL_33:.*]]:2 = fork [2] %[[VAL_31]] : i1
// CHECK:           %[[VAL_34:.*]] = mux %[[VAL_33]]#1 {{\[}}%[[VAL_29]], %[[VAL_35:.*]]] : i1, none
// CHECK:           %[[VAL_36:.*]] = mux %[[VAL_30]] {{\[}}%[[VAL_27]]] : index, i1
// CHECK:           %[[VAL_37:.*]] = mux %[[VAL_33]]#0 {{\[}}%[[VAL_36]], %[[VAL_38:.*]]] : i1, i1
// CHECK:           %[[VAL_39:.*]] = br %[[VAL_37]] : i1
// CHECK:           %[[VAL_40:.*]] = br %[[VAL_34]] : none
// CHECK:           %[[VAL_41:.*]] = merge %[[VAL_39]] : i1
// CHECK:           %[[VAL_42:.*]]:4 = fork [4] %[[VAL_41]] : i1
// CHECK:           %[[VAL_43:.*]], %[[VAL_44:.*]] = control_merge %[[VAL_40]] : none
// CHECK:           %[[VAL_45:.*]]:2 = fork [2] %[[VAL_43]] : none
// CHECK:           sink %[[VAL_44]] : index
// CHECK:           %[[VAL_46:.*]], %[[VAL_38]] = cond_br %[[VAL_42]]#2, %[[VAL_42]]#3 : i1
// CHECK:           sink %[[VAL_46]] : i1
// CHECK:           %[[VAL_47:.*]] = constant %[[VAL_45]]#0 {value = true} : i1
// CHECK:           %[[VAL_48:.*]] = arith.xori %[[VAL_42]]#0, %[[VAL_47]] : i1
// CHECK:           %[[VAL_32]] = merge %[[VAL_48]] : i1
// CHECK:           %[[VAL_49:.*]], %[[VAL_35]] = cond_br %[[VAL_42]]#1, %[[VAL_45]]#1 : none
// CHECK:           %[[VAL_50:.*]] = mux %[[VAL_13]]#1 {{\[}}%[[VAL_23]], %[[VAL_20]]] : i1, none
// CHECK:           %[[VAL_51:.*]] = arith.index_cast %[[VAL_13]]#0 : i1 to index
// CHECK:           sink %[[VAL_51]] : index
// CHECK:           %[[VAL_52:.*]] = br %[[VAL_50]] : none
// CHECK:           %[[VAL_53:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_49]], %[[VAL_52]]] : i1, none
// CHECK:           %[[VAL_54:.*]]:2 = fork [2] %[[VAL_53]] : none
// CHECK:           %[[VAL_55:.*]] = constant %[[VAL_54]]#0 {value = true} : i1
// CHECK:           %[[VAL_56:.*]] = arith.xori %[[VAL_5]]#0, %[[VAL_55]] : i1
// CHECK:           %[[VAL_57:.*]] = arith.index_cast %[[VAL_56]] : i1 to index
// CHECK:           sink %[[VAL_57]] : index
// CHECK:           return %[[VAL_54]]#1 : none
// CHECK:         }
func.func @otherBlockOrder(%arg0: i1) {
  cf.cond_br %arg0, ^bb1, ^bb4
^bb1:  // pred: ^bb0
  cf.cond_br %arg0, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  cf.br ^bb7
^bb3:  // pred: ^bb1
  cf.br ^bb7
^bb4:  // pred: ^bb0
  cf.br ^bb5
^bb5:  // 2 preds: ^bb4, ^bb6
  cf.br ^bb6
^bb6:  // pred: ^bb5
  cf.cond_br %arg0, ^bb8, ^bb5
^bb7:  // 2 preds: ^bb2, ^bb3
  cf.br ^bb8
^bb8:  // 2 preds: ^bb6, ^bb7
  return
}

// -----

// CHECK-LABEL:   handshake.func @multiple_block_args(
// CHECK-SAME:                                        %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                        %[[VAL_1:.*]]: i64,
// CHECK-SAME:                                        %[[VAL_2:.*]]: none, ...) -> none
// CHECK:           %[[VAL_3:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_4:.*]]:6 = fork [6] %[[VAL_3]] : i1
// CHECK:           %[[VAL_5:.*]] = buffer [2] fifo %[[VAL_4]]#0 : i1
// CHECK:           %[[VAL_6:.*]]:2 = fork [2] %[[VAL_5]] : i1
// CHECK:           %[[VAL_7:.*]] = merge %[[VAL_1]] : i64
// CHECK:           %[[VAL_8:.*]]:2 = fork [2] %[[VAL_7]] : i64
// CHECK:           %[[VAL_9:.*]], %[[VAL_10:.*]] = cond_br %[[VAL_4]]#4, %[[VAL_4]]#5 : i1
// CHECK:           sink %[[VAL_10]] : i1
// CHECK:           %[[VAL_11:.*]], %[[VAL_12:.*]] = cond_br %[[VAL_4]]#3, %[[VAL_8]]#1 : i64
// CHECK:           %[[VAL_13:.*]], %[[VAL_14:.*]] = cond_br %[[VAL_4]]#2, %[[VAL_8]]#0 : i64
// CHECK:           sink %[[VAL_13]] : i64
// CHECK:           %[[VAL_15:.*]], %[[VAL_16:.*]] = cond_br %[[VAL_4]]#1, %[[VAL_2]] : none
// CHECK:           %[[VAL_17:.*]] = merge %[[VAL_9]] : i1
// CHECK:           %[[VAL_18:.*]]:4 = fork [4] %[[VAL_17]] : i1
// CHECK:           %[[VAL_19:.*]] = buffer [2] fifo %[[VAL_18]]#0 : i1
// CHECK:           %[[VAL_20:.*]]:2 = fork [2] %[[VAL_19]] : i1
// CHECK:           %[[VAL_21:.*]], %[[VAL_22:.*]] = control_merge %[[VAL_15]] : none
// CHECK:           sink %[[VAL_22]] : index
// CHECK:           %[[VAL_23:.*]] = merge %[[VAL_11]] : i64
// CHECK:           %[[VAL_24:.*]]:2 = fork [2] %[[VAL_23]] : i64
// CHECK:           %[[VAL_25:.*]], %[[VAL_26:.*]] = cond_br %[[VAL_18]]#3, %[[VAL_21]] : none
// CHECK:           %[[VAL_27:.*]], %[[VAL_28:.*]] = cond_br %[[VAL_18]]#2, %[[VAL_24]]#1 : i64
// CHECK:           %[[VAL_29:.*]], %[[VAL_30:.*]] = cond_br %[[VAL_18]]#1, %[[VAL_24]]#0 : i64
// CHECK:           sink %[[VAL_29]] : i64
// CHECK:           %[[VAL_31:.*]], %[[VAL_32:.*]] = control_merge %[[VAL_25]] : none
// CHECK:           sink %[[VAL_32]] : index
// CHECK:           %[[VAL_33:.*]] = merge %[[VAL_27]] : i64
// CHECK:           sink %[[VAL_33]] : i64
// CHECK:           %[[VAL_34:.*]] = br %[[VAL_31]] : none
// CHECK:           %[[VAL_35:.*]], %[[VAL_36:.*]] = control_merge %[[VAL_26]] : none
// CHECK:           sink %[[VAL_36]] : index
// CHECK:           %[[VAL_37:.*]] = merge %[[VAL_30]] : i64
// CHECK:           sink %[[VAL_37]] : i64
// CHECK:           %[[VAL_38:.*]] = merge %[[VAL_28]] : i64
// CHECK:           sink %[[VAL_38]] : i64
// CHECK:           %[[VAL_39:.*]] = br %[[VAL_35]] : none
// CHECK:           %[[VAL_40:.*]], %[[VAL_41:.*]] = control_merge %[[VAL_16]] : none
// CHECK:           sink %[[VAL_41]] : index
// CHECK:           %[[VAL_42:.*]] = merge %[[VAL_14]] : i64
// CHECK:           sink %[[VAL_42]] : i64
// CHECK:           %[[VAL_43:.*]] = merge %[[VAL_12]] : i64
// CHECK:           sink %[[VAL_43]] : i64
// CHECK:           %[[VAL_44:.*]] = br %[[VAL_40]] : none
// CHECK:           %[[VAL_45:.*]] = mux %[[VAL_20]]#1 {{\[}}%[[VAL_39]], %[[VAL_34]]] : i1, none
// CHECK:           %[[VAL_46:.*]] = arith.index_cast %[[VAL_20]]#0 : i1 to index
// CHECK:           sink %[[VAL_46]] : index
// CHECK:           %[[VAL_47:.*]] = br %[[VAL_45]] : none
// CHECK:           %[[VAL_48:.*]] = mux %[[VAL_6]]#1 {{\[}}%[[VAL_44]], %[[VAL_47]]] : i1, none
// CHECK:           %[[VAL_49:.*]]:2 = fork [2] %[[VAL_48]] : none
// CHECK:           %[[VAL_50:.*]] = constant %[[VAL_49]]#0 {value = true} : i1
// CHECK:           %[[VAL_51:.*]] = arith.xori %[[VAL_6]]#0, %[[VAL_50]] : i1
// CHECK:           %[[VAL_52:.*]] = arith.index_cast %[[VAL_51]] : i1 to index
// CHECK:           sink %[[VAL_52]] : index
// CHECK:           return %[[VAL_49]]#1 : none
// CHECK:         }
func.func @multiple_block_args(%arg0: i1, %arg1: i64) {
  cf.cond_br %arg0, ^bb1(%arg1 : i64), ^bb4(%arg1, %arg1 : i64, i64)
^bb1(%0: i64):  // pred: ^bb0
  cf.cond_br %arg0, ^bb2(%0 : i64), ^bb3(%0, %0 : i64, i64)
^bb2(%1: i64):  // pred: ^bb1
  cf.br ^bb5
^bb3(%2: i64, %3: i64):  // pred: ^bb1
  cf.br ^bb5
^bb4(%4: i64, %5: i64):  // pred: ^bb0
  cf.br ^bb6
^bb5:  // 2 preds: ^bb2, ^bb3
  cf.br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  return
}

// -----

// CHECK-LABEL:   handshake.func @mergeBlockAsLoopHeader(
// CHECK-SAME:                                           %[[VAL_0:.*]]: i1,
// CHECK-SAME:                                           %[[VAL_1:.*]]: none, ...) -> none
// CHECK:           %[[VAL_2:.*]] = merge %[[VAL_0]] : i1
// CHECK:           %[[VAL_3:.*]]:4 = fork [4] %[[VAL_2]] : i1
// CHECK:           %[[VAL_4:.*]] = buffer [2] fifo %[[VAL_3]]#0 : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_4]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_3]]#2, %[[VAL_3]]#3 : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_3]]#1, %[[VAL_1]] : none
// CHECK:           %[[VAL_10:.*]] = merge %[[VAL_6]] : i1
// CHECK:           %[[VAL_11:.*]], %[[VAL_12:.*]] = control_merge %[[VAL_8]] : none
// CHECK:           sink %[[VAL_12]] : index
// CHECK:           %[[VAL_13:.*]] = br %[[VAL_10]] : i1
// CHECK:           %[[VAL_14:.*]] = br %[[VAL_11]] : none
// CHECK:           %[[VAL_15:.*]] = merge %[[VAL_7]] : i1
// CHECK:           %[[VAL_16:.*]], %[[VAL_17:.*]] = control_merge %[[VAL_9]] : none
// CHECK:           sink %[[VAL_17]] : index
// CHECK:           %[[VAL_18:.*]] = br %[[VAL_15]] : i1
// CHECK:           %[[VAL_19:.*]] = br %[[VAL_16]] : none
// CHECK:           %[[VAL_20:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_19]], %[[VAL_14]]] : i1, none
// CHECK:           %[[VAL_21:.*]]:2 = fork [2] %[[VAL_20]] : none
// CHECK:           %[[VAL_22:.*]] = arith.index_cast %[[VAL_5]]#0 : i1 to index
// CHECK:           %[[VAL_23:.*]] = buffer [1] seq %[[VAL_24:.*]] {initValues = [0]} : i1
// CHECK:           %[[VAL_25:.*]]:2 = fork [2] %[[VAL_23]] : i1
// CHECK:           %[[VAL_26:.*]] = mux %[[VAL_25]]#1 {{\[}}%[[VAL_21]]#1, %[[VAL_27:.*]]] : i1, none
// CHECK:           %[[VAL_28:.*]] = mux %[[VAL_22]] {{\[}}%[[VAL_18]], %[[VAL_13]]] : index, i1
// CHECK:           %[[VAL_29:.*]] = mux %[[VAL_25]]#0 {{\[}}%[[VAL_28]], %[[VAL_30:.*]]] : i1, i1
// CHECK:           %[[VAL_31:.*]]:4 = fork [4] %[[VAL_29]] : i1
// CHECK:           %[[VAL_32:.*]], %[[VAL_33:.*]] = cond_br %[[VAL_31]]#0, %[[VAL_31]]#1 : i1
// CHECK:           sink %[[VAL_32]] : i1
// CHECK:           %[[VAL_34:.*]] = constant %[[VAL_21]]#0 {value = true} : i1
// CHECK:           %[[VAL_35:.*]] = arith.xori %[[VAL_31]]#3, %[[VAL_34]] : i1
// CHECK:           %[[VAL_24]] = merge %[[VAL_35]] : i1
// CHECK:           %[[VAL_36:.*]], %[[VAL_37:.*]] = cond_br %[[VAL_31]]#2, %[[VAL_26]] : none
// CHECK:           %[[VAL_38:.*]] = merge %[[VAL_33]] : i1
// CHECK:           %[[VAL_39:.*]], %[[VAL_40:.*]] = control_merge %[[VAL_37]] : none
// CHECK:           sink %[[VAL_40]] : index
// CHECK:           %[[VAL_30]] = br %[[VAL_38]] : i1
// CHECK:           %[[VAL_27]] = br %[[VAL_39]] : none
// CHECK:           %[[VAL_41:.*]], %[[VAL_42:.*]] = control_merge %[[VAL_36]] : none
// CHECK:           sink %[[VAL_42]] : index
// CHECK:           return %[[VAL_41]] : none
// CHECK:         }
func.func @mergeBlockAsLoopHeader(%arg0: i1) {
  cf.cond_br %arg0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  cf.br ^bb3
^bb2:  // pred: ^bb0
  cf.br ^bb3
^bb3:  // pred: ^bb1, ^bb2, ^bb4
  cf.cond_br %arg0, ^bb5, ^bb4
^bb4:  // pred: ^bb1, ^bb2
  cf.br ^bb3
^bb5:  // 2 preds: ^bb3
  return
}
